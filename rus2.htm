<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Russian to English Parser Test</title>
  <style>
    /* Base Styles for the Body */
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to bottom right, #e3f2fd, #ffffff);
      color: #333333;
      margin: 0;
      padding: 0 10px;
    }

    /* Header Styles */
    h1, h2 {
      text-align: center;
      color: #004d99;
      font-weight: 700;
      margin: 20px 0;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
    }

    /* Input Area Styling */
    textarea {
      width: 90%;
      height: 180px;
      margin: 20px auto;
      display: block;
      font-size: 16px;
      font-family: 'Courier New', monospace;
      border: 2px solid #b3d9ff;
      border-radius: 10px;
      padding: 12px;
      background: #ffffff;
      color: #333333;
      outline: none;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: box-shadow 0.3s ease, border-color 0.3s ease;
    }

    textarea:focus {
      border-color: #0077cc;
      box-shadow: 0 6px 12px rgba(0, 119, 204, 0.3);
    }

    /* Button Styling with Animation */
    button {
      display: block;
      width: 220px;
      margin: 20px auto;
      padding: 10px 15px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      color: #ffffff;
      background: linear-gradient(45deg, #0077cc, #005499);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
    }

    button:hover {
      background: linear-gradient(45deg, #005499, #0077cc);
      transform: translateY(-2px);
      box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(2px);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    /* Output Area with Shadows and Borders */
    #output {
      width: 90%;
      margin: 20px auto;
      padding: 20px;
      border: 2px solid #b3d9ff;
      border-radius: 10px;
      background: #ffffff;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      font-family: 'Segoe UI', sans-serif;
      font-size: 16px;
      color: #333333;
      line-height: 1.6;
    }

    /* Styling Words and Definitions */
    .word {
      font-weight: bold;
      color: #004d99;
    }

    .definition {
      font-style: italic;
      color: #6c757d;
    }

    .prefix {
      color: #ff5733;
      font-weight: bold;
    }

    .suffix {
      color: #28a745;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Russian To English Parser Test</h1>
  <textarea id="inputText" rows="10" cols="50" placeholder="Paste Russian text here...">Локомотив принимал земляков из Динамо. Обозреватель медиахолдинга Pravda.Ru побывал на матче. Хозяевами были на стадионе.</textarea>
  <br>
  <button onclick="runMatcher()">Process this Russian text</button>
  <h2>Results:</h2>
  <div id="output"></div>
  <script>
    const dictionary = {
      "хозяевами": "hosts, with hosts"
    };

    const prefixes = {
      "хозя": "prefix meaning 'host'"
    };

    const suffixes = {
      "ами": "suffix meaning 'with'"
    };

    function removePunctuation(text) {
      return text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "");
    }

    function identifyParts(word, context) {
      let prefix = "";
      let suffix = "";
      let root = word;

      // Check for the longest prefix with a space to the left
      for (const p of Object.keys(prefixes).sort((a, b) => b.length - a.length)) {
        if (context.endsWith(" " + p)) {
          prefix = p;
          root = word.slice(p.length);
          break;
        }
      }

      // Check for the longest suffix that is followed by a space or end of the string
      for (const s of Object.keys(suffixes).sort((a, b) => b.length - a.length)) {
        if (root.endsWith(s) && (context.indexOf(root + s) === context.length - root.length - s.length || context.slice(context.length - root.length - s.length - 1, context.length - root.length - s.length) !== " ")) {
          suffix = s;
          root = root.slice(0, -s.length);
          break;
        }
      }

      return { prefix, root, suffix };
    }

    function matchDictionary(root) {
      return dictionary[root] || "No match found";
    }

    function processText(inputText) {
      const cleanedText = removePunctuation(inputText);
      const words = cleanedText.split(/\s+/);
      const results = words.map((word, index) => {
        const context = cleanedText.slice(0, cleanedText.indexOf(word) + word.length);
        const { prefix, root, suffix } = identifyParts(word, context);
        const definition = matchDictionary(root);
        return { word, prefix, root, suffix, definition };
      });
      return results;
    }

    function displayResults(results) {
      const outputDiv = document.getElementById("output");
      outputDiv.innerHTML = "";
      results.forEach(({ word, prefix, root, suffix, definition }) => {
        const wordDiv = document.createElement("div");
        wordDiv.innerHTML = `
          <span class="word">${word}</span>: 
          <span class="prefix">${prefix}</span>
          <span class="root">${root}</span>
          <span class="suffix">${suffix}</span>
          <span class="definition">${definition}</span>
        `;
        outputDiv.appendChild(wordDiv);
      });
    }

    function runMatcher() {
      const inputText = document.getElementById("inputText").value;
      const results = processText(inputText);
      displayResults(results);
    }
  </script>
</body>
</html>
