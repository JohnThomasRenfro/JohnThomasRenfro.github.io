<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AD&D Encounter Manager</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .sandbox {
            flex: 0 0 70%; /* Set the left side to 70% */
            background-color: #f0f0f0; /* Light background for visibility */
            overflow: auto; /* Makes the sandbox scrollable if content overflows */
            border-right: 2px solid #ccc; /* Optional: Add a border for separation */
            padding: 10px; /* Add some padding */
        }

        .controls {
            flex: 0 0 30%; /* Set the right side to 30% */
            background-color: #ffffff; /* White background for controls */
            padding: 10px; /* Add some padding */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1); /* Optional: Add a subtle shadow */
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        label {
            display: block; /* Stack labels and inputs */
            margin: 10px 0 5px; /* Spacing around labels */
        }

        input[type="text"], input[type="file"] { 
            padding: 5px; /* Add some padding */
            box-sizing: border-box; /* Include padding in width */
        }

        .upload-btn {
            display: inline-block;
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            text-align: center;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
        }

        .upload-btn:hover {
            background-color: #0056b3; /* Darken the button on hover */
        }

        /* Draggable CSS */
        .draggable {
            background-color: #d9edf7;
            border: 1px solid #31708f;
            border-radius: 5px;
            cursor: move; /* Cursor change to indicate draggable */
            padding: 10px;
		height: 100px; 
            margin: 5px;
            width: 100px; 
            position: relative; /* Required for absolute positioning (if needed) */
        }

        /* Optional additional styling for draggable pieces */
        .draggable img {
            max-width: 100%; /* Responsive images within draggable */
            display: block; /* Make sure image is displayed properly */
        }
    </style>
</head>
<body>

    <div class="sandbox" id="sandbox">
        <!-- Draggable pieces dynamically generated here -->
    </div>

    <div class="controls">

Name:
AC:			
                        <th>HP</th>
                        <th>ATTKS</th>
                        <th>GEAR</th>
                        <th>Image</th>
                        <th>Actions</th>
    

        <a href="https://archive.org/details/tsr09059d12descentintothedepthsoftheearth/page/n4/mode/1up" target="_blank">Module</a> |
        <a href="https://archive.org/details/dungeon-masters-screen/mode/1up" target="_blank">DM Screen</a>

        <label for="d100">D100:</label>
        <input type="text" id="d100" value="1d100+0">

        <label for="d20">D20:</label>
        <input type="text" id="d20" value="1d20+0">

        <label for="d12">D12:</label>
        <input type="text" id="d12" value="1d12+0">

        <label for="d10">D10:</label>
        <input type="text" id="d10" value="1d10+0">

        <label for="d8">D8:</label>
        <input type="text" id="d8" value="1d8+0">

        <label for="d6">D6:</label>
        <input type="text" id="d6" value="1d6+0">

        <label for="d4">D4:</label>
        <input type="text" id="d4" value="1d4+0">

        <button onclick="rollAllDice()">Roll</button>
        <p>Results:</p>
        <p id="results"></p>

        <div>
            <button onclick="addPiece()">Add Character/Monster</button>
        </div>



        <input type="file" id="mapInput" accept="image/*" onchange="setMapBackground()" />
        <label for="mapInput" class="upload-btn">Upload Map</label>
    </div>

 <script>
 let pieces = JSON.parse(localStorage.getItem("pieces")) || [];
 let currentDraggingPiece = null; // Keeps track of the currently dragged piece

const directions = [0, 45, 90, 135, 180, 225, 270, 315]; // Eight cardinal directions

 function rollDice(diceNotation) {
 const [countAndSides, modifier] = diceNotation.split('+').map((part) => part.trim());
 const [count, sides] = countAndSides.split('d').map(Number);
 const modifierValue = Number(modifier) || 0;

 let total = 0;
 for (let i = 0; i < count; i++) {
 total += Math.floor(Math.random() * sides) + 1; // Random roll
 }

 return total + modifierValue;
 }

 function rollAllDice() {
 const diceTypes = ['d100', 'd20', 'd12', 'd10', 'd8', 'd6', 'd4'];
 const resultsDiv = document.getElementById('results');
 resultsDiv.innerHTML = ''; // Clear previous results

 diceTypes.forEach((type) => {
 const input = document.getElementById(type);
 const diceNotation = input.value.trim();

 if (diceNotation) {
 const result = rollDice(diceNotation);
 const resultText = `|${type.toUpperCase()} result: ${result}`;
 resultsDiv.innerHTML += resultText; // Append result to the results div
 }
 });
 }


 function addPiece() {
 const newPiece = {
 id: Date.now(),
 name: "Unnamed",
 hp: 10,
 ac: 10,
 attks: 0,
 gear: "armor, weapon, rations",
 image: null,
 x: 50,
 y: 50,
 rotation: 0 // Default rotation
 };
 pieces.push(newPiece);
 saveToLocalStorage();
 renderPieces();
 renderStatsTable();
 }

 function clonePiece(id) {
 const original = pieces.find(p => p.id === id);
 const clone = { ...original, id: Date.now(), name: `${original.name} (Clone)` };
 clone.x += 10; // Offset for clarity
 clone.y += 10; // Offset for clarity
 pieces.push(clone);
 saveToLocalStorage();
 renderPieces();
 renderStatsTable();
 }
		
		function renderPieces() {
 const sandbox = document.getElementById("sandbox");
 sandbox.innerHTML = "";

 pieces.forEach((piece) => {
 const el = document.createElement("div");
 el.className = "draggable";
 el.textContent = piece.name; // Name is displayed again
 el.style.left = piece.x + "px";
 el.style.top = piece.y + "px";
 el.style.transform = `rotate(${piece.rotation}deg)`;
 el.id = `piece-${piece.id}`;

if (piece.image) {
 const img = document.createElement("img");
 img.src = piece.image;
 img.style.width = "100%";
 img.style.height = "100%";
 img.style.objectFit = "cover"; // Ensures the image fills the square without distortion
 el.appendChild(img);
}

 // Rotate symbol
 const rotate = document.createElement("div");
 rotate.className = "rotate-symbol";
 rotate.textContent = "âŸ³";
 rotate.onclick = () => rotatePiece(piece.id);
 el.appendChild(rotate);

 // Drag-and-drop behavior
 el.onmousedown = (event) => startDrag(event, piece.id);

 sandbox.appendChild(el);
 });
 }

function rotatePiece(id) {
 const piece = pieces.find(p => p.id === id);
 const currentIndex = directions.indexOf(piece.rotation);
 piece.rotation = directions[(currentIndex + 1) % directions.length]; // Rotate to the next direction
 saveToLocalStorage();
 renderPieces(); // Re-render the sandbox for immediate visual feedback
}


 function renderStatsTable() {
 const statsTable = document.querySelector("#statsTable tbody");
 statsTable.innerHTML = ""; // Clear existing rows

 pieces.forEach((piece) => {
 const row = document.createElement("tr");
 row.id = `row-${piece.id}`;

 // Name
 const nameCell = document.createElement("td");
 const nameInput = document.createElement("input");
 nameInput.type = "text";
 nameInput.value = piece.name;
 nameInput.oninput = (event) => {
 piece.name = event.target.value;
 saveToLocalStorage();
 renderPieces();
 };
 nameCell.appendChild(nameInput);
 row.appendChild(nameCell);

// AC Input
const acCell = document.createElement("td");
const acInput = document.createElement("input");
acInput.type = "text"; 
acInput.inputMode = "numeric"; 
acInput.value = piece.ac;
acInput.maxLength = 4; 
acInput.size = 4; 

acInput.oninput = (event) => {
 const inputValue = event.target.value;
 const validInputPattern = /^-?\d{0,4}$/;
 if (validInputPattern.test(inputValue)) {
 piece.ac = inputValue; 
 saveToLocalStorage(); 
 } else {
 // If input is invalid, revert to previous valid value
 event.target.value = piece.ac; 
 }
};
acCell.appendChild(acInput);
row.appendChild(acCell);

 // HP
 const hpCell = document.createElement("td");
 const hpInput = document.createElement("input");
 hpInput.type = "number";
 hpInput.value = piece.hp;
hpInput.maxLength = 4;
hpInput.size = 4;			 
 hpInput.oninput = (event) => {
 piece.hp = event.target.value;
 saveToLocalStorage();
 };
 hpCell.appendChild(hpInput);
 row.appendChild(hpCell);		 

// ATTKS Input
const attksCell = document.createElement("td");
const attksInput = document.createElement("input");
attksInput.type = "text"; // Use text type to avoid spinners
attksInput.inputMode = "numeric"; // Still allow numeric inputs
attksInput.value = piece.attks;
attksInput.oninput = (event) => {
 piece.attks = event.target.value;
 saveToLocalStorage();
};
attksCell.appendChild(attksInput);
row.appendChild(attksCell);

 // GEAR
 const gearCell = document.createElement("td");
 const gearInput = document.createElement("input");
 gearInput.type = "text";
 gearInput.value = piece.gear;
 gearInput.oninput = (event) => {
 piece.gear = event.target.value;
 saveToLocalStorage();
 };
 gearCell.appendChild(gearInput);
 row.appendChild(gearCell);

 // Image Upload
 const imageCell = document.createElement("td");
 const imageInput = document.createElement("input");
 imageInput.type = "file";
 imageInput.accept = "image/*";
 imageInput.onchange = (event) => {
 const file = event.target.files[0];
 if (file) {
 const reader = new FileReader();
 reader.onload = (e) => {
 piece.image = e.target.result;
 saveToLocalStorage();
 renderPieces();
 };
 reader.readAsDataURL(file);
 }
 };
 imageCell.appendChild(imageInput);
 row.appendChild(imageCell);

 // Actions (Clone and Delete Buttons)
 const actionsCell = document.createElement("td");
 const cloneBtn = document.createElement("button");
 cloneBtn.className = "clone-btn";
 cloneBtn.textContent = "Clone";
 cloneBtn.onclick = () => {
 clonePiece(piece.id);
 };
 actionsCell.appendChild(cloneBtn);

 const deleteBtn = document.createElement("button");
 deleteBtn.className = "delete-btn";
 deleteBtn.textContent = "Delete";
 deleteBtn.onclick = () => {
 pieces = pieces.filter(p => p.id !== piece.id);
 saveToLocalStorage();
 renderPieces();
 renderStatsTable();
 };
 actionsCell.appendChild(deleteBtn);

 row.appendChild(actionsCell);

 statsTable.appendChild(row);
 });
 }

 function startDrag(event, id) {
 currentDraggingPiece = id;
 const sandbox = document.getElementById("sandbox");

 sandbox.onmousemove = (e) => drag(e);
 sandbox.onmouseup = () => stopDrag();
 }

 function drag(event) {
 if (!currentDraggingPiece) return;

 const sandbox = document.getElementById("sandbox");
 const rect = sandbox.getBoundingClientRect();

 const piece = pieces.find(p => p.id === currentDraggingPiece);
 piece.x = event.clientX - rect.left - 60; // Center the piece
 piece.y = event.clientY - rect.top - 60;

 saveToLocalStorage();
 renderPieces();
 }

 function stopDrag() {
 currentDraggingPiece = null;
 const sandbox = document.getElementById("sandbox");
 sandbox.onmousemove = null;
 sandbox.onmouseup = null;
 }

 function saveToLocalStorage() {
 localStorage.setItem("pieces", JSON.stringify(pieces));
 }

function setMapBackground() {
 const input = document.getElementById("mapInput");
 const sandbox = document.getElementById("sandbox");
 
 if (input.files && input.files[0]) {
 const reader = new FileReader();
 reader.onload = (e) => {
 const backgroundImage = e.target.result; // Convert the image to a base64 string
 sandbox.style.backgroundImage = `url(${backgroundImage})`; // Set the sandbox background
 localStorage.setItem("mapBackground", backgroundImage); // Store the base64 URL in localStorage
 };
 reader.readAsDataURL(input.files[0]); // Read the file as a base64 string
 }
}

function loadMapBackground() {
 const sandbox = document.getElementById("sandbox");
 const savedBackground = localStorage.getItem("mapBackground");
 
 if (savedBackground) {
 sandbox.style.backgroundImage = `url(${savedBackground})`; // Retrieve and apply the stored background
 }
}


		// Initialize the sandbox, stats table, and background
loadMapBackground();
renderPieces();
renderStatsTable();
 </script>
</body>
</html>
