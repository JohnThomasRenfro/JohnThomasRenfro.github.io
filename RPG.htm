<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AD&D Encounter Manager</title>
body {
    font-family: "Fantasy", serif;
    background-color: #111;
    color: #f9f9f9;
    margin: 0;
    padding: 0;
}

.header {
    background: linear-gradient(to right, #4e1700, #a67c00);
    padding: 20px;
    text-align: center;
    box-shadow: 0 2px 15px #000;
}

h1 {
    margin: 0;
    color: #ffeb3b;
    font-size: 2.5em;
    text-shadow: 3px 3px #000;
}

.controls {
    padding: 15px;
    background: #333;
    text-align: center;
}

button, .upload-btn {
    font-size: 1.2em;
    padding: 10px 15px;
    margin: 5px;
    color: white;
    background: #5c2400;
    border: none;
    cursor: pointer;
    border-radius: 8px;
}

button:hover, .upload-btn:hover {
    background-color: #a0522d;
}

.sandbox {
    width: 100%;
    height: 3000px;
    background: url("default-map.jpg") center/cover no-repeat;
    position: relative;
    overflow: hidden;
    border: 5px solid #a67c00;
}

.draggable {
    width: 50px;
    height: 50px;
    position: absolute;
    background: #800000; /* Red background */
    color: white;
    text-align: center;
    line-height: unset; /* Removed to allow name positioning */
    cursor: grab;
    box-shadow: 2px 2px 10px #000;
}

.rotate-symbol {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 20px;
    height: 20px;
    background-color: #ffd700;
    color: #000;
    font-weight: bold;
    text-align: center;
    line-height: 20px;
    border-radius: 50%;
    cursor: pointer;
}

img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
}

#statsEditor {
    background: #222;
    padding: 20px;
    border-top: 2px solid #a67c00;
}

table {
    width: 100%;
    color: #f9f9f9;
    border-collapse: collapse;
}

th, td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #444;
}

.delete-btn, .clone-btn {
    background: #5c2400;
    border: none;
    color: #fff;
    padding: 5px 10px;
    cursor: pointer;
    border-radius: 5px;
}

.delete-btn:hover {
    background: #b30000;
}

.clone-btn:hover {
    background: #a0522d;
}

/* Style for input fields */
input[type="number"], input[type="text"], textarea {
    background-color: #333;
    color: #f9f9f9;
    border: 1px solid #444;
    padding: 8px 12px;
    font-size: 1em;
    border-radius: 5px;
    width: 100%;
    margin: 5px 0;
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
}

/* Focus state for input fields */
input[type="number"]:focus, input[type="text"]:focus, textarea:focus {
    background-color: #555;
    border-color: #a67c00;
    outline: none;
}

/* Remove the default spin buttons on number inputs */
input[type="number"]::-webkit-outer-spin-button, 
input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

/* Style for the range input (if you use it) */
input[type="range"] {
    width: 100%;
    margin: 10px 0;
}

input[type="range"]:focus {
    outline: none;
}
</head>
<body>
    <a href="https://archive.org/details/tsr09059d12descentintothedepthsoftheearth/page/n4/mode/1up" target="_blank">Module</a>|
    <a href="https://archive.org/details/dungeon-masters-screen/mode/1up" target="_blank">DM Screen</a>|
    
    <div class="header">
        <h1>üõ°Ô∏è AD&D Encounter Manager üêâ</h1>
    </div>

    <label for="d100">D100: </label>
    <input type="text" id="d100" value="1d100+0">

    <label for="d20">D20: </label>
    <input type="text" id="d20" value="1d20+0">

    <label for="d12">D12: </label>
    <input type="text" id="d12" value="1d12+0">

    <label for="d10">D10: </label>
    <input type="text" id="d10" value="1d10+0">

    <label for="d8">D8: </label>
    <input type="text" id="d8" value="1d8+0">

    <label for="d6">D6: </label>
    <input type="text" id="d6" value="1d6+0">

    <label for="d4">D4: </label>
    <input type="text" id="d4" value="1d4+0">

    <button onclick="rollAllDice()">Roll</button>
    Results:
    <p id="results"></p>

    <div class="controls">
        <button onclick="addPiece()">Add Character/Monster</button>
    </div>

    <div id="statsEditor">
        <h2>Stats Overview</h2>
        <table id="statsTable">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>HP</th>
                    <th>AC</th>
                    <th>ATTKS</th>
                    <th>GEAR</th>
                    <th>Image</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- Rows dynamically added here -->
            </tbody>
        </table>
    </div>
    
    <input type="file" id="mapInput" accept="image/*" onchange="setMapBackground()" />
    <label for="mapInput" class="upload-btn">Upload Map</label>

    <div class="sandbox" id="sandbox">
        <!-- Draggable pieces dynamically generated here -->
    </div>
</body>
	

    <script>
        let pieces = JSON.parse(localStorage.getItem("pieces")) || [];
        let currentDraggingPiece = null; // Keeps track of the currently dragged piece

const directions = [0, 45, 90, 135, 180, 225, 270, 315]; // Eight cardinal directions

        function rollDice(diceNotation) {
            const [countAndSides, modifier] = diceNotation.split('+').map((part) => part.trim());
            const [count, sides] = countAndSides.split('d').map(Number);
            const modifierValue = Number(modifier) || 0;

            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * sides) + 1; // Random roll
            }

            return total + modifierValue;
        }

        function rollAllDice() {
            const diceTypes = ['d100', 'd20', 'd12', 'd10', 'd8', 'd6', 'd4'];
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = ''; // Clear previous results

            diceTypes.forEach((type) => {
                const input = document.getElementById(type);
                const diceNotation = input.value.trim();

                if (diceNotation) {
                    const result = rollDice(diceNotation);
                    const resultText = `|${type.toUpperCase()} result: ${result}`;
                    resultsDiv.innerHTML += resultText; // Append result to the results div
                }
            });
        }


        function addPiece() {
            const newPiece = {
                id: Date.now(),
                name: "Unnamed",
                hp: 10,
                ac: 10,
                attks: 0,
                gear: "armor, weapon, rations",
                image: null,
                x: 50,
                y: 50,
                rotation: 0 // Default rotation
            };
            pieces.push(newPiece);
            saveToLocalStorage();
            renderPieces();
            renderStatsTable();
        }

        function clonePiece(id) {
            const original = pieces.find(p => p.id === id);
            const clone = { ...original, id: Date.now(), name: `${original.name} (Clone)` };
            clone.x += 10; // Offset for clarity
            clone.y += 10; // Offset for clarity
            pieces.push(clone);
            saveToLocalStorage();
            renderPieces();
            renderStatsTable();
        }
		
function renderPieces() {
    const sandbox = document.getElementById("sandbox");
    sandbox.innerHTML = ""; // Clear the sandbox before re-rendering the pieces

    pieces.forEach((piece) => {
        const el = document.createElement("div");
        el.className = "draggable";
        el.textContent = piece.name; // Display the name on the piece
        el.style.left = piece.x + "px";
        el.style.top = piece.y + "px";
        el.style.transform = `rotate(${piece.rotation}deg)`;
        el.id = `piece-${piece.id}`;

        // Add image if available
        if (piece.image) {
            const img = document.createElement("img");
            img.src = piece.image;
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "cover"; // Ensures the image fills the square without distortion
            el.appendChild(img);
        }

        // Rotate symbol
        const rotate = document.createElement("div");
        rotate.className = "rotate-symbol";
        rotate.textContent = "‚ü≥";
        rotate.onclick = () => rotatePiece(piece.id);
        el.appendChild(rotate);

        // Apply drag-and-drop behavior to the entire piece
        el.addEventListener("mousedown", (event) => startDrag(event, piece.id));
        el.addEventListener("touchstart", (event) => startDrag(event, piece.id), { passive: false }); // Added touchstart for mobile

        sandbox.appendChild(el);
    });
}

// Start dragging function
function startDrag(e, pieceId) {
    e.preventDefault(); // Prevent any unwanted default behavior (like text selection or scrolling)

    let touch = e.touches ? e.touches[0] : e; // Use touch or mouse event based on the device
    let draggedElement = document.getElementById(`piece-${pieceId}`);

    // Ensure dragging starts only if the element is properly selected
    if (!draggedElement) return;

    // Calculate initial offset (difference between the touch point and element's top-left corner)
    let rect = draggedElement.getBoundingClientRect();
    let offsetX = touch.clientX - rect.left;
    let offsetY = touch.clientY - rect.top;

    // Handle dragging
    const doDrag = (e) => {
        let touch = e.touches ? e.touches[0] : e; // Use touch or mouse event based on the device
        draggedElement.style.position = "absolute"; // Ensure the element is positioned absolutely
        draggedElement.style.left = touch.clientX - offsetX + "px"; // Update position based on touch
        draggedElement.style.top = touch.clientY - offsetY + "px";

        e.preventDefault(); // Prevent any default scrolling or other behaviors
    };

    // Stop dragging function
    const stopDrag = () => {
        // Update the piece's position in the array
        const piece = pieces.find((p) => p.id === pieceId);
        const rect = draggedElement.getBoundingClientRect();
        piece.x = rect.left;
        piece.y = rect.top;

        // Clear drag listeners
        document.removeEventListener("mousemove", doDrag);
        document.removeEventListener("touchmove", doDrag);
        document.removeEventListener("mouseup", stopDrag);
        document.removeEventListener("touchend", stopDrag);
    };

    // Attach event listeners for dragging
    document.addEventListener("mousemove", doDrag);
    document.addEventListener("touchmove", doDrag, { passive: false }); // Ensure passive is false for touchmove
    document.addEventListener("mouseup", stopDrag);
    document.addEventListener("touchend", stopDrag);
}

// Rotate piece function to only rotate in 45 degree increments (cardinal directions)
function rotatePiece(id) {
    const piece = pieces.find(p => p.id === id);
    
    // Define the 8 cardinal rotation angles: 0, 45, 90, 135, 180, 225, 270, 315
    const cardinalDirections = [0, 45, 90, 135, 180, 225, 270, 315];
    
    // Get current rotation angle (default to 0 if it's not defined yet)
    let currentRotation = piece.rotation || 0;

    // Find the next rotation in the cardinalDirections array
    let currentIndex = cardinalDirections.indexOf(currentRotation);
    let nextIndex = (currentIndex + 1) % cardinalDirections.length;

    // Update the piece's rotation to the next cardinal direction
    piece.rotation = cardinalDirections[nextIndex];

    saveToLocalStorage(); // Save the state
    renderPieces(); // Re-render the sandbox for immediate visual feedback
}

// Function to save to localStorage
function saveToLocalStorage() {
    localStorage.setItem('pieces', JSON.stringify(pieces)); // Save pieces array to localStorage
}

// Initialize pieces on page load (retrieving from localStorage)
document.addEventListener("DOMContentLoaded", function () {
    const storedPieces = JSON.parse(localStorage.getItem("pieces"));
    if (storedPieces) {
        pieces = storedPieces;
    }
    renderPieces(); // Render pieces after loading
});

        function renderStatsTable() {
            const statsTable = document.querySelector("#statsTable tbody");
            statsTable.innerHTML = ""; // Clear existing rows

            pieces.forEach((piece) => {
                const row = document.createElement("tr");
                row.id = `row-${piece.id}`;

                // Name
                const nameCell = document.createElement("td");
                const nameInput = document.createElement("input");
                nameInput.type = "text";
                nameInput.value = piece.name;
                nameInput.oninput = (event) => {
                    piece.name = event.target.value;
                    saveToLocalStorage();
                    renderPieces();
                };
                nameCell.appendChild(nameInput);
                row.appendChild(nameCell);

                // HP
                const hpCell = document.createElement("td");
                const hpInput = document.createElement("input");
                hpInput.type = "number";
                hpInput.value = piece.hp;
                hpInput.oninput = (event) => {
                    piece.hp = event.target.value;
                    saveToLocalStorage();
                };
                hpCell.appendChild(hpInput);
                row.appendChild(hpCell);

// AC Input
const acCell = document.createElement("td");
const acInput = document.createElement("input");
acInput.type = "text"; // Use text type to avoid spinners
acInput.inputMode = "numeric"; // Still allow numeric inputs
acInput.value = piece.ac;
acInput.oninput = (event) => {
    piece.ac = event.target.value;
    saveToLocalStorage();
};
acCell.appendChild(acInput);
row.appendChild(acCell);

// ATTKS Input
const attksCell = document.createElement("td");
const attksInput = document.createElement("input");
attksInput.type = "text"; // Use text type to avoid spinners
attksInput.inputMode = "numeric"; // Still allow numeric inputs
attksInput.value = piece.attks;
attksInput.oninput = (event) => {
    piece.attks = event.target.value;
    saveToLocalStorage();
};
attksCell.appendChild(attksInput);
row.appendChild(attksCell);

                // GEAR
                const gearCell = document.createElement("td");
                const gearInput = document.createElement("input");
                gearInput.type = "text";
                gearInput.value = piece.gear;
                gearInput.oninput = (event) => {
                    piece.gear = event.target.value;
                    saveToLocalStorage();
                };
                gearCell.appendChild(gearInput);
                row.appendChild(gearCell);

                // Image Upload
                const imageCell = document.createElement("td");
                const imageInput = document.createElement("input");
                imageInput.type = "file";
                imageInput.accept = "image/*";
                imageInput.onchange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            piece.image = e.target.result;
                            saveToLocalStorage();
                            renderPieces();
                        };
                        reader.readAsDataURL(file);
                    }
                };
                imageCell.appendChild(imageInput);
                row.appendChild(imageCell);

                // Actions (Clone and Delete Buttons)
                const actionsCell = document.createElement("td");
                const cloneBtn = document.createElement("button");
                cloneBtn.className = "clone-btn";
                cloneBtn.textContent = "Clone";
                cloneBtn.onclick = () => {
                    clonePiece(piece.id);
                };
                actionsCell.appendChild(cloneBtn);

                const deleteBtn = document.createElement("button");
                deleteBtn.className = "delete-btn";
                deleteBtn.textContent = "Delete";
                deleteBtn.onclick = () => {
                    pieces = pieces.filter(p => p.id !== piece.id);
                    saveToLocalStorage();
                    renderPieces();
                    renderStatsTable();
                };
                actionsCell.appendChild(deleteBtn);

                row.appendChild(actionsCell);

                statsTable.appendChild(row);
            });
        }

        function startDrag(event, id) {
            currentDraggingPiece = id;
            const sandbox = document.getElementById("sandbox");

            sandbox.onmousemove = (e) => drag(e);
            sandbox.onmouseup = () => stopDrag();
        }

        function drag(event) {
            if (!currentDraggingPiece) return;

            const sandbox = document.getElementById("sandbox");
            const rect = sandbox.getBoundingClientRect();

            const piece = pieces.find(p => p.id === currentDraggingPiece);
            piece.x = event.clientX - rect.left - 60; // Center the piece
            piece.y = event.clientY - rect.top - 60;

            saveToLocalStorage();
            renderPieces();
        }

        function stopDrag() {
            currentDraggingPiece = null;
            const sandbox = document.getElementById("sandbox");
            sandbox.onmousemove = null;
            sandbox.onmouseup = null;
        }

        function saveToLocalStorage() {
            localStorage.setItem("pieces", JSON.stringify(pieces));
        }

function setMapBackground() {
    const input = document.getElementById("mapInput");
    const sandbox = document.getElementById("sandbox");
    
    if (input.files && input.files[0]) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const backgroundImage = e.target.result; // Convert the image to a base64 string
            sandbox.style.backgroundImage = `url(${backgroundImage})`; // Set the sandbox background
            localStorage.setItem("mapBackground", backgroundImage); // Store the base64 URL in localStorage
        };
        reader.readAsDataURL(input.files[0]); // Read the file as a base64 string
    }
}

function loadMapBackground() {
    const sandbox = document.getElementById("sandbox");
    const savedBackground = localStorage.getItem("mapBackground");
    
    if (savedBackground) {
        sandbox.style.backgroundImage = `url(${savedBackground})`; // Retrieve and apply the stored background
    }
}


		// Initialize the sandbox, stats table, and background
loadMapBackground();
renderPieces();
renderStatsTable();
    </script>
</html>
